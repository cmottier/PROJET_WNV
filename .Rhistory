axisPhylo()
################################################################################
## Data
################################################################################
## Import the data
dat <- read.table(here("data", "WNV_lat_long.txt"), header = TRUE)
head(dat)
## Match
# Match the data with the tips of the tree, so that they are in the same order
match(tree$tip.label, dat$traits)
dat <- dat[match(tree$tip.label, dat$traits), ]
match(tree$tip.label, dat$traits)
## Plot tree and data
plot(tree, show.tip.label = FALSE, x.lim = 25)
phydataplot(dat$lat, tree, offset = 1, scaling = 0.1)
phydataplot(dat$long, tree, offset = 15, scaling = 0.05)
# Same plot, without the warnings : vectors need to be named.
lat <- dat$lat
long <- dat$long
names(lat) <- names(long) <- dat$traits
plot(tree, show.tip.label = FALSE, x.lim = 25)
phydataplot(lat, tree, offset = 1, scaling = 0.1)
phydataplot(long, tree, offset = 15, scaling = 0.05)
?corMatrix
?corBrownian
?mrca
getMRCA(tree,19,108)
getMRCA(tree,c(19,108))
# Donne l'ancêtre direct et le poids de l'arête associée
ancetre_direct <- function(noeud) {
res = NULL
aretes <- tree$edge
poids <- tree$edge.length
nb_aretes <- nrow(tree$edge)
for (i in 1:nb_aretes) {
if (aretes[i,2]==noeud) {return(matrix(c(aretes[i,1],poids[i])))}
}
return(res)
}
# Donne tous les ancêtres et les poids des arêtes associées (poids fils-ancêtre affiché sous l'ancêtre)
ancetres <- function(noeud) {
res = NULL
if (is.null(ancetre_direct(noeud))) {return(res)}
else {
a <- ancetre_direct(noeud)
res = cbind(res, cbind(a, ancetres(a[1])))
}
return(res)
}
ancetres(19,108)
ancetres(19)
ancetres(108)
?reconstruct
?distroot
?distRoot
distRoot(tree,1)
?root.edge
?root.edge
root.edge(tree)
?root
?node.depth.edgelength()
node.depth.edgelength(tree)
ancetres(1)
ancetres(2)
sum(0.552+0.477)
Cn <- matrix(nrow=104, ncol=104)
for (i in 1:104) {
for (j in i:104) {
ancetre <- getMRCA(tree,c(i,j))
t_ij <- node.depth.edgelength(ancetre)
C[i,j] <- t_ij
C[j,i] <- t_ij
}
return(Cn)
}
Cn <- matrix(nrow=104, ncol=104)
for (i in 1:104) {
for (j in i:104) {
ancetre <- getMRCA(tree,c(i,j))
tij <- node.depth.edgelength(ancetre)
C[i,j] <- tij
C[j,i] <- tij
}
return(Cn)
}
Cn <- matrix(nrow=104, ncol=104)
for (i in 1:104) {
for (j in i:104) {
ancetre <- getMRCA(tree,c(i,j))
# tij <- node.depth.edgelength(ancetre)
# C[i,j] <- tij
# C[j,i] <- tij
}
return(Cn)
}
getMRCA(tree,c(1,2))
a=getMRCA(tree,c(1,2))
node.depth.edgelength(a)
?as.integer
as.integer(a)
class(a)
a=getMRCA(tree,c(1,2))
class(a)
node.depth.edgelength(105)
node.depth.edgelength(1)
node.depth.edgelength(tree,1)
?node.depth.edgelength
Cn <- matrix(nrow=104, ncol=104)
for (i in 1:104) {
for (j in i:104) {
ancetre <- getMRCA(tree,c(i,j))
tij <- node.depth.edgelength(ancetre)[ancetre]
C[i,j] <- tij
C[j,i] <- tij
}
return(Cn)
}
Cn <- matrix(nrow=104, ncol=104)
for (i in 1:104) {
for (j in i:104) {
ancetre <- getMRCA(tree,c(i,j))
tij <- node.depth.edgelength(tree)[ancetre]
C[i,j] <- tij
C[j,i] <- tij
}
return(Cn)
}
ancetre <- getMRCA(tree,c(1,2))
tij <- node.depth.edgelength(tree)[ancetre]
tij
class(tij)
# Construction de C, avec les fonctions de ape...
Cn <- matrix(nrow=104, ncol=104)
for (i in 1:104) {
for (j in i:104) {
ancetre <- getMRCA(tree,c(i,j))
tij <- node.depth.edgelength(tree)[ancetre]
Cn[i,j] <- tij
Cn[j,i] <- tij
}
return(Cn)
}
Cn
# Construction de C, avec les fonctions de ape...
Cn <- matrix(nrow=104, ncol=104)
for (i in 1:104) {
for (j in i:104) {
ancetre <- getMRCA(tree,c(i,j))
tij <- node.depth.edgelength(tree)[ancetre]
Cn[i,j] <- tij
Cn[j,i] <- tij
}
return(Cn)
}
Cn
ancetre <- getMRCA(tree,c(2,45))
ancetre
tij <- node.depth.edgelength(tree)[ancetre]
tij
class(tij)
Cn <- matrix(nrow=104, ncol=104)
Cn[2,45]<- tij
Cn
Cn <- matrix(nrow=104, ncol=104)
for (i in 1:104) {
for (j in i:104) {
ancetre <- getMRCA(tree,c(i,j))
tij <- node.depth.edgelength(tree)[ancetre]
Cn[i,j] <- tij
Cn[j,i] <- tij
}
return(Cn)
}
Cn
Cn <- matrix(nrow=104, ncol=104)
for (i in 1:104) {
for (j in i:104) {
ancetre <- getMRCA(tree,c(i,j))
print(ancetre)
tij <- node.depth.edgelength(tree)[ancetre]
print(tij)
Cn[i,j] <- tij
Cn[j,i] <- tij
}
return(Cn)
}
ancetre <- getMRCA(tree,c(2,45))
ancetre
Cn <- matrix(nrow=104, ncol=104)
for (i in 1:104) {
for (j in i:104) {
ancetre <- getMRCA(tree,c(i,j))
print(ancetre)
tij <- node.depth.edgelength(tree)[ancetre]
# print(tij)
# Cn[i,j] <- tij
# Cn[j,i] <- tij
}
# return(Cn)
}
Cn <- matrix(nrow=104, ncol=104)
for (i in 1:104) {
for (j in i:104) {
ancetre <- getMRCA(tree,c(i,j))
print(ancetre)
tij <- node.depth.edgelength(tree)[ancetre]
print(tij)
# Cn[i,j] <- tij
# Cn[j,i] <- tij
}
# return(Cn)
}
tij
Cn <- matrix(nrow=104, ncol=104)
for (i in 1:104) {
for (j in (i:104)) {
ancetre <- getMRCA(tree,c(i,j))
print(ancetre)
tij <- node.depth.edgelength(tree)[ancetre]
print(tij)
Cn[i,j] <- tij
Cn[j,i] <- tij
}
}
Cn <- matrix(nrow=104, ncol=104)
for (i in 1:104) {
for (j in (i:104)) {
ancetre <- getMRCA(tree,c(i,j))
tij <- node.depth.edgelength(tree)[ancetre]
Cn[i,j] <- tij
Cn[j,i] <- tij
}
}
Cn
invCn <- solve(Cn)
C <- matrix(nrow=104, ncol=104)
for (i in 1:104) {
for (j in i:104) {
C[i,j] <- temps_commun(i,j)
C[j,i] <- temps_commun(j,i)
}
}
# Donne l'ancêtre direct et le poids de l'arête associée
ancetre_direct <- function(noeud) {
res = NULL
aretes <- tree$edge
poids <- tree$edge.length
nb_aretes <- nrow(tree$edge)
for (i in 1:nb_aretes) {
if (aretes[i,2]==noeud) {return(matrix(c(aretes[i,1],poids[i])))}
}
return(res)
}
# Donne tous les ancêtres et les poids des arêtes associées (poids fils-ancêtre affiché sous l'ancêtre)
ancetres <- function(noeud) {
res = NULL
if (is.null(ancetre_direct(noeud))) {return(res)}
else {
a <- ancetre_direct(noeud)
res = cbind(res, cbind(a, ancetres(a[1])))
}
return(res)
}
# Donne le poids de l'arête commune à deux noeuds
temps_commun <- function(noeud1,noeud2) {
if (noeud1 == noeud2) {
return(sum(ancetres(noeud1)[2,]))}
else {
anc1 <- cbind(matrix(c(noeud1,0), nrow=2),ancetres(noeud1))
anc2 <- cbind(matrix(c(noeud2,0), nrow=2),ancetres(noeud2))
res = 0
l1 <- ncol(anc1)
l2 <- ncol(anc2)
while (anc1[1,l1-1]==anc2[1,l2-1]) {
res = res +anc1[2,l1]
l1 <- l1-1
l2 <- l2-1
if (l1==1 | l2==1) {return(res)}
}
return(res)}
}
C <- matrix(nrow=104, ncol=104)
for (i in 1:104) {
for (j in i:104) {
C[i,j] <- temps_commun(i,j)
C[j,i] <- temps_commun(j,i)
}
}
C
Cn
invC <- solve(C)
invCn <- solve(Cn)
getMRCA(tree,c(1,1))
Cn <- matrix(nrow=104, ncol=104)
for (i in 1:104) {
Cn[i,j] <- node.depth.edgelength(tree)[i]
for (j in ((i+1):104)) {
ancetre <- getMRCA(tree,c(i,j))
tij <- node.depth.edgelength(tree)[ancetre]
Cn[i,j] <- tij
Cn[j,i] <- tij
}
}
Cn <- matrix(nrow=104, ncol=104)
for (i in 1:104) {
Cn[i,j] <- node.depth.edgelength(tree)[i]
}
node.depth.edgelength(tree)
node.depth.edgelength(tree)[104]
Cn <- matrix(nrow=104, ncol=104)
for (i in 1:104) {
Cn[i,i] <- node.depth.edgelength(tree)[i]
}
for (i in 1:103) {
for (j in ((i+1):104)) {
ancetre <- getMRCA(tree,c(i,j))
tij <- node.depth.edgelength(tree)[ancetre]
Cn[i,j] <- tij
Cn[j,i] <- tij
}
}
Cn
invCn <- solve(Cn)
Un <- matrix(rep(1,104),ncol=1)
Y <- as.matrix(dat[,2:3])
mut <- solve(t(Un)%*%invCn%*%Un)%*%t(Un)%*%invCn%*%Y
R <- 1/103*t(Y-Un%*%mut)%*%invCn%*%(Y-Un%*%mut)
mut
invC <- solve(C)
Un <- matrix(rep(1,104),ncol=1)
Y <- as.matrix(dat[,2:3])
mut <- solve(t(Un)%*%invC%*%Un)%*%t(Un)%*%invC%*%Y
R <- 1/103*t(Y-Un%*%mut)%*%invC%*%(Y-Un%*%mut)
mut
Cn <- matrix(nrow=104, ncol=104)
for (i in 1:104) {
Cn[i,i] <- node.depth.edgelength(tree)[i]
}
for (i in 1:103) {
for (j in ((i+1):104)) {
ancetre <- getMRCA(tree,c(i,j))
tij <- node.depth.edgelength(tree)[ancetre]
Cn[i,j] <- tij
Cn[j,i] <- tij
}
}
invCn <- solve(Cn)
Un <- matrix(rep(1,104),ncol=1)
Y <- as.matrix(dat[,2:3])
mut <- solve(t(Un)%*%invCn%*%Un)%*%t(Un)%*%invCn%*%Y
R <- 1/103*t(Y-Un%*%mut)%*%invCn%*%(Y-Un%*%mut)
mut
ancetre_direct <- function(noeud) {
res = NULL
aretes <- tree$edge
poids <- tree$edge.length
nb_aretes <- nrow(tree$edge)
for (i in 1:nb_aretes) {
if (aretes[i,2]==noeud) {return(matrix(c(aretes[i,1],poids[i])))}
}
return(res)
}
# Donne tous les ancêtres et les poids des arêtes associées (poids fils-ancêtre affiché sous l'ancêtre)
ancetres <- function(noeud) {
res = NULL
if (is.null(ancetre_direct(noeud))) {return(res)}
else {
a <- ancetre_direct(noeud)
res = cbind(res, cbind(a, ancetres(a[1])))
}
return(res)
}
# Donne le poids de l'arête commune à deux noeuds
temps_commun <- function(noeud1,noeud2) {
if (noeud1 == noeud2) {
return(sum(ancetres(noeud1)[2,]))}
else {
anc1 <- cbind(matrix(c(noeud1,0), nrow=2),ancetres(noeud1))
anc2 <- cbind(matrix(c(noeud2,0), nrow=2),ancetres(noeud2))
res = 0
l1 <- ncol(anc1)
l2 <- ncol(anc2)
while (anc1[1,l1-1]==anc2[1,l2-1]) {
res = res +anc1[2,l1]
l1 <- l1-1
l2 <- l2-1
if (l1==1 | l2==1) {return(res)}
}
return(res)}
}
# Crée la matrice C
C <- matrix(nrow=104, ncol=104)
for (i in 1:104) {
for (j in i:104) {
C[i,j] <- temps_commun(i,j)
C[j,i] <- temps_commun(j,i)
}
}
# Construction de C, avec les fonctions de ape...
Cn <- matrix(nrow=104, ncol=104)
for (i in 1:104) {
Cn[i,i] <- node.depth.edgelength(tree)[i]
}
for (i in 1:103) {
for (j in ((i+1):104)) {
ancetre <- getMRCA(tree,c(i,j))
tij <- node.depth.edgelength(tree)[ancetre]
Cn[i,j] <- tij
Cn[j,i] <- tij
}
}
# Estimateurs de mu et R
invC <- solve(C)
Un <- matrix(rep(1,104),ncol=1)
Y <- as.matrix(dat[,2:3])
mut <- solve(t(Un)%*%invC%*%Un)%*%t(Un)%*%invC%*%Y
R <- 1/103*t(Y-Un%*%mut)%*%invC%*%(Y-Un%*%mut)
# Avec Cn
invCn <- solve(Cn)
Un <- matrix(rep(1,104),ncol=1)
Y <- as.matrix(dat[,2:3])
mut <- solve(t(Un)%*%invCn%*%Un)%*%t(Un)%*%invCn%*%Y
R <- 1/103*t(Y-Un%*%mut)%*%invCn%*%(Y-Un%*%mut)
mut
R
?corBrownian
corBrownian(1,tree)
corBrownian(1,tree, form=~1)
# Estimateur MB (Mardia)
MB_ancestral <- mut
# Allocate locations to the data table (first tips, then nodes)
rec_table[["location1"]] <- c(dat$lat, rep(MB_ancestral[1], n_nodes))
library(treeio) # "tree input/output"
# This is to export the data to a format that can be read by EvoLaps
# It exports the data as an "extended newick"
# First create a table with tips and node reference numbers
rec_table <- list(node = seq_len(n_tips + n_nodes))
# # This is a very dumb ancestral reconstruction, just for the example : all ancestral nodes are at the same location
# dumb_ancestral <- c(mean(lat), mean(long))
# # Allocate locations to the data table (first tips, then nodes)
# rec_table[["location1"]] <- c(dat$lat, rep(dumb_ancestral[1], n_nodes))
# rec_table[["location2"]] <- c(dat$long, rep(dumb_ancestral[2], n_nodes))
# Estimateur MB (Mardia)
MB_ancestral <- mut
# Allocate locations to the data table (first tips, then nodes)
rec_table[["location1"]] <- c(dat$lat, rep(MB_ancestral[1], n_nodes))
rec_table[["location2"]] <- c(dat$long, rep(MB_ancestral[2], n_nodes))
# Format the data to export it
rec_table <- as_tibble(rec_table)
tree_tibble <- as_tibble(tree)
tree_data <- full_join(tree_tibble, rec_table, by = 'node')
tree_data <- as.treedata(tree_data)
# Write the extended newick. The resulting file can be read by Evolaps.
write.beast(tree_data, file = here("results", "tree_with_data_MB.tree"), tree.name = "TREE_MB")
X = matrix(c(1,7,1,12,1,5),nrow=3)
X = matrix(c(1,7,1,12,1,5),nrow=3, byrow = T)
X
D=matrix(c(1,0,0,0,2,0,0,0,2), nrow=3,byrow=T)
Y=matrix(c(15,25,10), nrow=3)
solve(t(X)%*%D%*%X)%*%t(X)%*%D%*%Y
solve(t(X)%*%D%*%X)%*%t(X)%*%D%*%Y*254
library(here) # To deal with paths : project must be root, and data must be in a folder named "data".
library(ape)  # R package for phylogenetic trees
################################################################################
## Tree
################################################################################
## Import the tree
tree <- read.tree(here("data", "WNV_Pybus2012_MCC.newick"))
str(tree)
n_nodes <- tree$Nnode
n_tips <- length(tree$tip.label)
# See help(read.tree) for the structure of the tree in R
## Plot the tree
plot(tree)
axisPhylo()
################################################################################
## Data
################################################################################
## Import the data
dat <- read.table(here("data", "WNV_lat_long.txt"), header = TRUE)
head(dat)
## Match
# Match the data with the tips of the tree, so that they are in the same order
match(tree$tip.label, dat$traits)
dat <- dat[match(tree$tip.label, dat$traits), ]
match(tree$tip.label, dat$traits)
## Plot tree and data
plot(tree, show.tip.label = FALSE, x.lim = 25)
phydataplot(dat$lat, tree, offset = 1, scaling = 0.1)
phydataplot(dat$long, tree, offset = 15, scaling = 0.05)
# Same plot, without the warnings : vectors need to be named.
lat <- dat$lat
long <- dat$long
names(lat) <- names(long) <- dat$traits
plot(tree, show.tip.label = FALSE, x.lim = 25)
phydataplot(lat, tree, offset = 1, scaling = 0.1)
phydataplot(long, tree, offset = 15, scaling = 0.05)
################################################################################
## treedata
# Construction de C, avec les fonctions de ape...
Cn <- matrix(nrow=104, ncol=104)
for (i in 1:104) {
Cn[i,i] <- node.depth.edgelength(tree)[i]
}
for (i in 1:103) {
for (j in ((i+1):104)) {
ancetre <- getMRCA(tree,c(i,j))
tij <- node.depth.edgelength(tree)[ancetre]
Cn[i,j] <- tij
Cn[j,i] <- tij
}
}
