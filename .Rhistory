}
}
# Matrice T des temps des feuilles
T <- matrix(nrow=104, ncol=1)
for (i in 1:104) {
T[i] <- C[i,i]
}
# Estimateurs de mu et R
invC <- solve(C)
Un <- matrix(rep(1,104),ncol=1)
X <- cbind(Un,T)
Y <- as.matrix(dat[,2:3])
theta <- solve(t(X)%*%invC%*%X)%*%t(X)%*%invC%*%Y
R_d <- 1/102*t(Y)%*%invC%*%(Y-X%*%theta)
# Construction de Cnoeud, basée sur tous les noeuds
f <- function(x) {
if (x<105) return(x)
else return(x+1)
}
Cnoeud <- matrix(nrow=206, ncol=206) # On enlève la racine 105
for (i in 1:206) {
Cnoeud[i,i] <- node.depth.edgelength(tree)[f(i)]
}
for (i in 1:205) {
for (j in ((i+1):206)) {
ancetre <- getMRCA(tree,c(f(i),f(j)))
tij <- node.depth.edgelength(tree)[ancetre]
Cnoeud[i,j] <- tij
Cnoeud[j,i] <- tij
}
}
Tm <- matrix(nrow=102, ncol=1)
for (i in 1:102) {
Tm[i] <- Cnoeud[i+104,i+104]
}
Um <- matrix(rep(1,102),ncol=1)
RC_d <- kronecker(R_d,Cnoeud, FUN = "*")
vecY <- matrix(Y, ncol=1, byrow = F)
mY_d <- matrix(Un%*%theta[1,]+T%*%theta[2,], ncol=1, byrow =F)
mX_d <- matrix(Um%*%theta[1,]+Tm%*%theta[2,], ncol=1, byrow=F)
SigmaXY_d <- rbind(cbind(RC_d[105:206,1:104],RC_d[105:206,207:310]),cbind(RC_d[311:412,1:104],RC_d[311:412,207:310]))
SigmaY_d <- rbind(cbind(RC_d[1:104,1:104],RC_d[1:104,207:310]),cbind(RC_d[207:310,1:104],RC_d[207:310,207:310]))
Estimateur_d <- mX_d + SigmaXY_d%*%solve(SigmaY_d)%*%(vecY-mY_d)
Estimateur_d
theta
library(here) # To deal with paths : project must be root, and data must be in a folder named "data".
library(ape)  # R package for phylogenetic trees
################################################################################
## Tree
################################################################################
## Import the tree
tree <- read.tree(here("data", "WNV_Pybus2012_MCC.newick"))
str(tree)
n_nodes <- tree$Nnode
n_tips <- length(tree$tip.label)
## Plot the tree
plot(tree)
axisPhylo()
################################################################################
## Data
################################################################################
## Import the data
dat <- read.table(here("data", "WNV_lat_long.txt"), header = TRUE)
head(dat)
## Match
# Match the data with the tips of the tree, so that they are in the same order
match(tree$tip.label, dat$traits)
dat <- dat[match(tree$tip.label, dat$traits), ]
match(tree$tip.label, dat$traits)
## Plot tree and data
plot(tree, show.tip.label = FALSE, x.lim = 25)
phydataplot(dat$lat, tree, offset = 1, scaling = 0.1)
phydataplot(dat$long, tree, offset = 15, scaling = 0.05)
# Same plot, without the warnings : vectors need to be named.
lat <- dat$lat
long <- dat$long
names(lat) <- names(long) <- dat$traits
plot(tree, show.tip.label = FALSE, x.lim = 25)
phydataplot(lat, tree, offset = 1, scaling = 0.1)
mtext("Latitude",1,at=12.5,line=3)
args.barplot=list(xlab="latitude")
phydataplot(long, tree, offset = 15, scaling = 0.05)
mtext("Longitude",1,at=21,line=3)
library(mvMORPH)
C <- vcv(tree)
invC<-solve(C)
Un <- matrix(rep(1,104),ncol = 1)
help(mvSIM)
# simulations:
mvSIM(tree = tree, nsim = 1, model = "BM1", param = list(sigma = sigma, theta = theta, trend = c(1,2)))
# simulations:
mvSIM(tree = tree, nsim = 1, model = "BM1", param = list(sigma = sigma, theta = mu, trend = c(1,2)))
# variance
Sigma <- matrix(c(1,-1,-1,2),nrow = 2)
# moyenne (ancetre)
mu = c(1,1)
## paramètres pour l'estimation
C <- vcv(tree)
invC<-solve(C)
Un <- matrix(rep(1,104),ncol = 1)
# simulations:
mvSIM(tree = tree, nsim = 1, model = "BM1", param = list(sigma = sigma, theta = mu, trend = c(1,2)))
# simulations:
mvSIM(tree = tree, nsim = 1, model = "BM1", param = list(sigma = sigma, theta = mu))
# variance
sigma <- matrix(c(1,-1,-1,2),nrow = 2)
# simulations:
mvSIM(tree = tree, nsim = 1, model = "BM1", param = list(sigma = sigma, theta = mu, trend = c(1,2)))
err <- NULL
for(i in 1:10000){
fit <- mvSIM(tree = tree, nsim = 1, model = "BM1", param = list(sigma = sima, theta = mu))
mu_est <- solve(t(Un)%*%invC%*%Un)%*%t(Un)%*%invC%*%fit
err[i]<- sum((mu - mu_est)^2)
}
for(i in 1:10000){
fit <- mvSIM(tree = tree, nsim = 1, model = "BM1", param = list(sigma = sigma, theta = mu))
mu_est <- solve(t(Un)%*%invC%*%Un)%*%t(Un)%*%invC%*%fit
err[i]<- sum((mu - mu_est)^2)
}
mean(err)
boxplot(err)
# simulations:
sim <- mvSIM(tree = tree, nsim = 10000, model = "BM1", param = list(sigma = sigma, theta = mu))
sim
for(i in 1:10000){
y<-sim[[i]]
mu_est <- solve(t(Un)%*%invC%*%Un)%*%t(Un)%*%invC%*%y
err[i]<- sum((mu - mu_est)^2)
err[i] <- (sum((mu-mu_est)^2)) / sum(mu^2)
}
mean(err)
boxplot(err)
boxplot(err_norm)
err <- NULL
err_norm <- NULL
for(i in 1:10000){
#y<-mvSIM(tree = tree, nsim = 1, model = "BM1", param = list(sigma = sigma, theta = mu))
y <- sim[[i]]
mu_est <- solve(t(Un)%*%invC%*%Un)%*%t(Un)%*%invC%*%y
err[i]<- sum((mu - mu_est)^2)
err_norm[i] <- (sum((mu-mu_est)^2)) / sum(mu^2)
}
mean(err)
boxplot(err)
boxplot(err_norm)
boxplot(err,main = "Boxplot des erreurs d'estimation")
err_moy <- mean(err)
err_min <- err_moy - 1.96*sqrt(var(err)/n)
err_max <- err_moy + 1.96*sqrt(var(err)/n)
err_min <- err_moy - 1.96*sqrt(var(err)/10000)
err_max <- err_moy + 1.96*sqrt(var(err)/10000)
c(err_min,err_moy,err_max)
help("boxplot")
sim <- mvSIM(tree = tree, nsim = 10000, model = "BM1", param = list(sigma = sigma, theta = mu))
err <- NULL
err_mu1 <- NULL
err_mu2 <- NULL
err_norm <- NULL
for(i in 1:10000){
#y<-mvSIM(tree = tree, nsim = 1, model = "BM1", param = list(sigma = sigma, theta = mu))
y <- sim[[i]] # simulation n°i
mu_est <- solve(t(Un)%*%invC%*%Un)%*%t(Un)%*%invC%*%y #estimateur de mu (ancêtre)
err_mu1[i] <- (mu[1] - mu_est[1])^2 #erreur sur la première composante
err_mu2[i] w- (mu[2] - mu_est[2])^2 #erreur sur la deuxième composante
err <- NULL
err_mu1 <- NULL
err_mu2 <- NULL
err_norm <- NULL
for(i in 1:10000){
#y<-mvSIM(tree = tree, nsim = 1, model = "BM1", param = list(sigma = sigma, theta = mu))
y <- sim[[i]] # simulation n°i
mu_est <- solve(t(Un)%*%invC%*%Un)%*%t(Un)%*%invC%*%y #estimateur de mu (ancêtre)
err_mu1[i] <- (mu[1] - mu_est[1])^2 #erreur sur la première composante
err_mu2[i] <- (mu[2] - mu_est[2])^2 #erreur sur la deuxième composante
err[i]<- sum((mu - mu_est)^2)
err_norm[i] <- (sum((mu-mu_est)^2)) / sum(mu^2)
}
err_moy <- mean(err)
err_min <- err_moy - 1.96*sqrt(var(err)/10000)
err_max <- err_moy + 1.96*sqrt(var(err)/10000)
c(err_min,err_moy,err_max) # intervalle de confiance ?
# erreur sur la première composante
err_mu1_moy <- mean(err_mu1)
err_mu1_min <- err_mu1_moy - 1.96*sqrt(var(err_mu1)/10000)
err_mu1_max <- err_mu1_moy + 1.96*sqrt(var(err_mu1)/10000)
c(err_mu1_min, err_mu1_moy, err_mu1_moy)
# erreur sur la deuxième composante
err_mu2_moy <- mean(err_mu2)
err_mu2_min <- err_mu2_moy - 1.96*sqrt(var(err_mu2)/10000)
err_mu2_max <- err_mu2_moy + 1.96*sqrt(var(err_mu2)/10000)
c(err_mu2_min,err_mu2_moy,err_mu2_max)
boxplot(c(err_mu1,err_mu2))
boxplot(err_mu1)
boxplot(err_mu2)
max(err)
boxplot(err,main = "Boxplot des erreurs d'estimation",range = 1)
boxplot(err,main = "Boxplot des erreurs d'estimation",range = 100)
boxplot(err,main = "Boxplot des erreurs d'estimation",range = 0)
boxplot(err,main = "Boxplot des erreurs d'estimation",range = 1)
boxplot(err,main = "Boxplot des erreurs d'estimation",range = 1,ylim = c(-1,6))
T <- diag(C)
X <- cbind(Un,T)
X
T <- matrix(diag(C))
X <- cbind(Un,T)
X
T <- matrix(diag(C))
X <- cbind(Un,T)
sim <- mvSIM(tree = tree, nsim = 1000, model = "BM1", param = list(sigma = sigma, theta = mu))
AIC <- NULL
AICd <- NULL
for(i in 1:1000){
Y <- sim[[i]]
L_hat <- -104*log(2*pi)-104/2*log(det(R))-log(det(C)) -1/2* sum(diag(solve(R)%*%t(Y-Un%*%mut)%*%solve(C)%*%(Y-Un%*%mut)))
L_hat_d <- -104*log(2*pi)-104/2*log(det(R_d))-log(det(C)) -1/2* sum(diag(solve(R_d)%*%t(Y-X%*%theta)%*%solve(C)%*%(Y-X%*%theta)))
AIC[i] <- -2*L_hat + 2*6
AICd[i] <- -2*L_hat_d + log(104)*8
}
T <- matrix(diag(C))
X <- cbind(Un,T)
sim <- mvSIM(tree = tree, nsim = 1000, model = "BM1", param = list(sigma = sigma, theta = mu))
AIC <- NULL
AICd <- NULL
for(i in 1:1000){
Y <- sim[[i]]
mut <- solve(t(Un)%*%invC%*%Un)%*%t(Un)%*%invC%*%Y
R <- 1/103*t(Y-Un%*%mut)%*%invC%*%(Y-Un%*%mut)
theta <- solve(t(X)%*%invC%*%X)%*%t(X)%*%invC%*%Y
R_d <- 1/102*t(Y)%*%invC%*%(Y-X%*%theta)
L_hat <- -104*log(2*pi)-104/2*log(det(R))-log(det(C)) -1/2* sum(diag(solve(R)%*%t(Y-Un%*%mut)%*%solve(C)%*%(Y-Un%*%mut)))
L_hat_d <- -104*log(2*pi)-104/2*log(det(R_d))-log(det(C)) -1/2* sum(diag(solve(R_d)%*%t(Y-X%*%theta)%*%solve(C)%*%(Y-X%*%theta)))
AIC[i] <- -2*L_hat + 2*6
AICd[i] <- -2*L_hat_d + log(104)*8
}
NULL + 1
s <- 0
for(i in 1:1000){
if(AIC[i]<=AICd[i]){
s = s+1
}
}
s
AIC
AICd
simd <- mvSIM(tree = tree, nsim = 1000, model = "BM1", param = list(sigma = sigma, theta = mu, trend = c(1,2)))
AIC2 <- NULL
AIC2d <- NULL
for(i in 1:1000){
Y <- sim[[i]]
mut <- solve(t(Un)%*%invC%*%Un)%*%t(Un)%*%invC%*%Y
R <- 1/103*t(Y-Un%*%mut)%*%invC%*%(Y-Un%*%mut)
theta <- solve(t(X)%*%invC%*%X)%*%t(X)%*%invC%*%Y
R_d <- 1/102*t(Y)%*%invC%*%(Y-X%*%theta)
L_hat <- -104*log(2*pi)-104/2*log(det(R))-log(det(C)) -1/2* sum(diag(solve(R)%*%t(Y-Un%*%mut)%*%solve(C)%*%(Y-Un%*%mut)))
L_hat_d <- -104*log(2*pi)-104/2*log(det(R_d))-log(det(C)) -1/2* sum(diag(solve(R_d)%*%t(Y-X%*%theta)%*%solve(C)%*%(Y-X%*%theta)))
AIC2[i] <- -2*L_hat + 2*6
AIC2d[i] <- -2*L_hat_d + log(104)*8
}
s <- 0
for(i in 1:1000){
if(AIC2[i] <= AIC2d[i]){
s = s + 1
}
}
s
Y <- as.matrix(dat[,2:3])
mut <- solve(t(Un)%*%invC%*%Un)%*%t(Un)%*%invC%*%Y
R <- 1/103*t(Y-Un%*%mut)%*%invC%*%(Y-Un%*%mut)
### simuler un brownien avec les paramètres estimés
simul <- mvSIM(tree = tree, nsim = 1, model = "BM1", param = list(sigma = R, theta = mut))
simul
Y
(Y-simul)^2
(Y-simul)^2/Y
plot((Y-simul)^2/Y)
library(here) # To deal with paths : project must be root, and data must be in a folder named "data".
library(ape)  # R package for phylogenetic trees
library(mvMORPH)
################################################################################
## Tree
################################################################################
## Import the tree
tree <- read.tree(here("data", "WNV_Pybus2012_MCC.newick"))
str(tree)
n_nodes <- tree$Nnode
n_tips <- length(tree$tip.label)
## Plot the tree
plot(tree)
axisPhylo()
help("axisPhylo")
## Plot the tree
plot(tree)
axisPhylo(backward = FALSE)
axisPhylo()
## Plot the tree
plot(tree)
axisPhylo()
################################################################################
## Data
################################################################################
## Import the data
dat <- read.table(here("data", "WNV_lat_long.txt"), header = TRUE)
dat <- dat[match(tree$tip.label, dat$traits), ]
## Plot tree and data
plot(tree, show.tip.label = FALSE, x.lim = 25)
phydataplot(dat$lat, tree, offset = 1, scaling = 0.1)
phydataplot(dat$long, tree, offset = 15, scaling = 0.05)
# Same plot, without the warnings : vectors need to be named.
lat <- dat$lat
long <- dat$long
names(lat) <- names(long) <- dat$traits
plot(tree, show.tip.label = FALSE, x.lim = 25)
phydataplot(lat, tree, offset = 1, scaling = 0.1)
mtext("Latitude",1,at=12.5,line=3)
args.barplot=list(xlab="latitude")
phydataplot(long, tree, offset = 15, scaling = 0.05)
mtext("Longitude",1,at=21,line=3)
axisPhylo()
################################################################################
## treedata
################################################################################
library(treeio) # "tree input/output"
# variance
sigma <- matrix(c(1,-1,-1,2),nrow = 2)
# moyenne (ancetre)
mu = c(1,1)
# dérive
b <- c(1,2)
mu_hat <- list()
mu1_hat <- NULL
mu2_hat <- NULL
err1 <- NULL
err2 <- NULL
for(i in 10:500){
tree_sim <- rtree(n=i,equiprob = FALSE) #on augmente le nb de feuilles de l'arbre à chaque itération
sim_bm <- mvSIM(tree = tree_sim, nsim = 1, model = "BM1", param = list(sigma = sigma, theta = mu))
## paramètres d'estimation
n<-length(tree_sim$tip.label)
C <- vcv(tree_sim)
invC<-solve(C)
Un<-matrix(rep(1,i),ncol = 1)
mu_hat[[i]] <- solve(t(Un)%*%invC%*%Un)%*%t(Un)%*%invC%*%sim_bm
mu1_hat[i] <- mu_hat[[i]][1]
err1[i] <- mu[1] - mu1_hat[i]
mu2_hat[i] <- mu_hat[[i]][2]
err2[i] <- mu[2] - mu2_hat[i]
}
plot(x = 10:500, y = cummean(mu1_hat[10:500]), type = 'l')
library(dplyr)
plot(x = 10:500, y = cummean(mu1_hat[10:500]), type = 'l')
plot(x = 10:500, y = mu1_hat[10:500],type = "l")
help(rtree)
## arbre à 10 feuilles
tree10 <- rtree(n=10,equiprob = FALSE)
MB10 <- mvSIM(tree = tree10, nsim = 10000, model = "BM1", param = list(sigma = sigma, theta = mu))
C10 <- vcv(tree10)
U10 <- matrix(rep(1,10),ncol = 1)
invC10 <- solve(C10)
mu10 <- list()
mu1_10 <- NULL
mu2_10 <- NULL
for(i in 1:10000){
mu10[[i]] <- solve(t(U10)%*%invC10%*%U10)%*%t(U10)%*%invC10%*%MB10[[i]]
mu1_10[i] <- mu10[[i]][1]
mu2_10[i] <- mu10[[i]][2]
}
boxplot(mu1_10)
boxplot(mu2_10)
tree50 <- rtree(n = 50, equiprob = FALSE)
MB50 <- mvSIM(tree = tree50, nsim = 10000, model = "BM1", param = list(sigma = sigma, theta = mu))
C50 <- vcv(tree50)
U50 <- matrix(rep(1,50),ncol = 1)
invC50 <- solve(C50)
mu50 <- list()
mu1_50 <- NULL
mu2_50 <- NULL
for(i in 1:10000){
mu50[[i]] <- solve(t(U50)%*%invC50%*%U50)%*%t(U50)%*%invC50%*%MB50[[i]]
mu1_50[i] <- mu50[[i]][1]
mu2_50[i] <- mu50[[i]][2]
}
boxplot(mu1_50)
boxplot(mu2_50)
tree100 <- rtree(n = 100, equiprob = FALSE)
MB100 <- mvSIM(tree = tree100, nsim = 10000, model = "BM1", param = list(sigma = sigma, theta = mu))
C100 <- vcv(tree100)
U100 <- matrix(rep(1,100),ncol = 1)
invC100 <- solve(C100)
mu100 <- list()
mu1_100 <- NULL
mu2_100 <- NULL
for(i in 1:10000){
mu100[[i]] <- solve(t(U100)%*%invC100%*%U100)%*%t(U100)%*%invC100%*%MB100[[i]]
mu1_100[i] <- mu100[[i]][1]
mu2_100[i] <- mu100[[i]][2]
}
tree500 <- rtree(n = 500, equiprob = FALSE)
MB500 <- mvSIM(tree = tree500, nsim = 10000, model = "BM1", param = list(sigma = sigma, theta = mu))
C500 <- vcv(tree500)
U500 <- matrix(rep(1,500),ncol = 1)
invC500 <- solve(C500)
mu500 <- list()
mu1_500 <- NULL
mu2_500 <- NULL
for(i in 1:10000){
mu500[[i]] <- solve(t(U500)%*%invC500%*%U500)%*%t(U500)%*%invC500%*%MB500[[i]]
mu1_500[i] <- mu500[[i]][1]
mu2_500[i] <- mu500[[i]][2]
}
### arbre à 1000 feuilles
tree1000 <- rtree(n=1000, equiprob = FALSE)
MB1000 <- mvSIM(tree = tree1000, nsim = 10000, model = "BM1", param = list(sigma = sigma, theta = mu))
C1000 <- vcv(tree1000)
U1000 <- matrix(rep(1,1000),ncol = 1)
invC1000 <- solve(C1000)
mu1000 <- list()
mu1_1000 <- NULL
mu2_1000 <- NULL
for(i in 1:10000){
mu1000[[i]] <- solve(t(U1000)%*%invC1000%*%U1000)%*%t(U1000)%*%invC1000%*%MB1000[[i]]
mu1_1000[i] <- mu1000[[i]][1]
mu2_1000[i] <- mu1000[[i]][2]
}
boxplot(mu1_10)
boxplot(mu1_50)
boxplot(mu1_10)
boxplot(mu1_50)
boxplot(mu1_100)
boxplot(mu1_500)
boxplot(mu1_1000)
boxplot(mu1_10)
boxplot(mu1_50)
boxplot(mu1_100)
boxplot(mu1_500)
boxplot(mu1_1000)
boxplot(mu1_10)
boxplot(mu1_50)
boxplot(mu1_100)
boxplot(mu1_500)
boxplot(mu1_1000)
data <- data.frame(cbind(mu1_10,mu1_50,mu1_100,mu1_500,mu1_1000))
View(data)
boxplo(data)
boxplot(data)
### arbre à 1000 feuilles
tree1000 <- rtree(n=1000, equiprob = FALSE)
MB1000 <- mvSIM(tree = tree1000, nsim = 10000, model = "BM1", param = list(sigma = sigma, theta = mu))
C1000 <- vcv(tree1000)
U1000 <- matrix(rep(1,1000),ncol = 1)
invC1000 <- solve(C1000)
mu1000 <- list()
mu1_1000 <- NULL
mu2_1000 <- NULL
for(i in 1:10000){
mu1000[[i]] <- solve(t(U1000)%*%invC1000%*%U1000)%*%t(U1000)%*%invC1000%*%MB1000[[i]]
mu1_1000[i] <- mu1000[[i]][1]
mu2_1000[i] <- mu1000[[i]][2]
}
data <- data.frame(cbind(mu1_10,mu1_50,mu1_100,mu1_500,mu1_1000))
boxplot(data)
data_mu2 <- data.frame(cbind(mu2_10,mu2_50,mu2_100,mu2_500,mu2_1000))
boxplot(data_mu2)
library(ellipse)
C <- vcv(tree)
invC <- solve(C)
Un <- matrix(rep(1,104),ncol=1)
Y <- as.matrix(dat[,2:3])
mut <- solve(t(Un)%*%invC%*%Un)%*%t(Un)%*%invC%*%Y
R <- 1/103*t(Y-Un%*%mut)%*%invC%*%(Y-Un%*%mut)
MB_ancestral <- mut
Cmn <- matrix(nrow=102, ncol=104)
for (i in 1:102) {
for (j in (1:104)) {
ancetre <- getMRCA(tree,c(i+105,j))
tij <- node.depth.edgelength(tree)[ancetre]
Cmn[i,j] <- tij
}
}
# Mettre sous forme vec
vecY <- matrix(Y, ncol=1, byrow = F)
mY <- matrix(Un%*%mut, ncol=1, byrow =F)
Um <- matrix(rep(1,102),ncol=1)
mZ <- matrix(Um%*%mut, ncol=1, byrow=F)
# Estimateur
Estimateur <- mZ + kronecker(diag(2),(Cmn%*%solve(C)), FUN = "*")%*%(vecY-mY)
# Estimateur des noeuds intermédiaires
X <- Estimateur
VAR <- R
level <- 0.90
CI <- ellipse::ellipse(VAR,center = MB_ancestral, level = 0.90)
# store the x and y values as lists
trait_name_lat <- paste0("location1_", level * 100, "%HPD")
trait_name_long <- paste0("location2_", level * 100, "%HPD")
rec_table[[paste0(trait_name_lat, "_", 1)]] <- c(rep(NA, n_tips), lapply(1:n_nodes, function(i) MB_ancestral[, 1]))
# This is to export the data to a format that can be read by EvoLaps
# It exports the data as an "extended newick"
# First create a table with tips and node reference numbers
rec_table <- list(node = seq_len(n_tips + n_nodes))
rec_table[[paste0(trait_name_lat, "_", 1)]] <- c(rep(NA, n_tips), lapply(1:n_nodes, function(i) MB_ancestral[, 1]))
rec_table[[paste0(trait_name_long, "_", 1)]] <- c(rep(NA, n_tips), lapply(1:n_nodes, function(i) MB_ancestral[, 2]))
# Format the data to export it
rec_table <- as_tibble(rec_table)
tree_tibble <- as_tibble(tree)
tree_data <- full_join(tree_tibble, rec_table, by = 'node')
tree_data <- as.treedata(tree_data)
# Write the extended newick. The resulting file can be read by Evolaps.
#write.beast(tree_data, file = here("results", "tree_MB.tree"), tree.name = "TREE_MB")
write.beast(tree_data, file = here("results", "tree_MB.tree"), tree.name = "TREE_MB_CI")
getwd()
# Write the extended newick. The resulting file can be read by Evolaps.
#write.beast(tree_data, file = here("results", "tree_MB.tree"), tree.name = "TREE_MB")
write.beast(tree_data, file = here("results", "tree_MB_CI.tree"), tree.name = "TREE_MB_CI")
